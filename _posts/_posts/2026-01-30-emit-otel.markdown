---
layout: post
title: "Using emit to send diagnostics to the OpenTelemetry SDK"
date: 2026-01-30 14:00:00 +1000
categories: rust
---

<img src="https://raw.githubusercontent.com/emit-rs/emit/v0.11.0-alpha.5/asset/logo-with-text.svg" alt="The emit logo" width="150" height="150" style="display: block; margin: 0 auto" />

I've spent some time recently improving [`emit`](https://github.com/emit-rs/emit)'s integration with the [OpenTelemetry SDK](https://github.com/open-telemetry/opentelemetry-rust). If you're not familiar, `emit` is a framework for instrumenting your Rust applications with logs, traces, and metrics. The OpenTelemetry project builds and maintains SDKs for collecting and exporting these same signals in many common languages, including Rust.

The result is the [`emit_opentelemetry`](https://github.com/emit-rs/emit_opentelemetry) crate. Here's how it looks:

```toml
# emit
[dependencies.emit]
version = "1"

[dependencies.emit_opentelemetry]
version = "0.31"

# opentelemetry
[dependencies.opentelemetry_sdk]
version = "0.31"
features = ["rt-tokio", "trace", "logs"]

[dependencies.opentelemetry]
version = "0.31"
features = ["trace", "logs"]

```

```rust
use opentelemetry_otlp::WithTonicConfig as _;

#[tokio::main]
async fn main() {
    // 1. Configure the OpenTelemetry SDK
    //    The full configuration isn't important here, you just need
    //    a `LoggerProvider` and `TracerProvider`
    let (logger_provider, tracer_provider) = configure_opentelemetry().await;

    // 2. Configure `emit` to point to `opentelemetry`
    //    This is the only bit of plumbing needed between `emit` and the OpenTelemetry SDK
    let _ = emit_opentelemetry::setup(logger_provider.clone(), tracer_provider.clone()).init();

    // Your app code goes here
    {
        #[derive(serde::Serialize)]
        struct User<'a> {
            id: u32,
            name: &'a str,
        }

        // `emit` spans are managed by the OpenTelemetry SDK, and emitted as spans
        #[emit::span("Greet {user}", #[emit::as_serde] user)]
        async fn greet(user: &User) {
            // `emit` logs are recorded as log records
            emit::info!("Hello, {user: user.name}!");
        }

        greet(&User { id: 1, name: "Rust" }).await;
    }

    // Shutdown the SDK
    let _ = logger_provider.shutdown();
    let _ = tracer_provider.shutdown();
}
```

What this means is you can use [`emit`'s APIs](https://emit-rs.io/producing-events.html) to instrument your applications instead of the OpenTelemetry SDK directly, falling back to it for things `emit` doesn't natively support, like sampling.

While I'm personally not a fan of the OpenTelemetry SDK's design (this is largely down to the API specification that all implementations must follow, rather than the Rust `opentelemetry` crates themselves), I think it serves an important role as a common target for other frameworks to integrate with, and as a baseline for expected behaviour. Instead of `log`, `tracing`, `emit`, `fastrace`, etc all needing to integrate with eachother, they can instead just integrate with the OpenTelemetry SDK.

I've made a [little sample application](https://github.com/emit-rs/emit_opentelemetry/blob/main/examples/multi_framework/src/main.rs) making sure `emit` (via `emit_opentelemetry`), [`log`](https://github.com/rust-lang/log) (via [`opentelemetry-appender-log`](https://github.com/open-telemetry/opentelemetry-rust/tree/main/opentelemetry-appender-log)), and [`tracing`](https://github.com/tokio-rs/tracing) (via [`tracing-opentelemetry`](https://github.com/tokio-rs/tracing-opentelemetry)) all get along when sharing the OpenTelemetry SDK, and it all works quite well. If anything, I think this is an achievement for `tracing-opentelemetry`. `tracing` predates OpenTelemetry and takes inspiration from the earlier OpenTracing model. It's also evolved a feature rich runtime of its own over years of active support. I imagine bridging those two stacks would be challenging.

Generally speaking, the main concern for a framework integrating with the OpenTelemetry SDK is around handling of trace context between them. Frameworks need to use the OpenTelemetry SDK as the source of truth for span context, otherwise you'll get broken traces when they're mixed. That includes communicating and respecting any sampling decisions made when starting traces.

I haven't explored metric integration yet. I think this will prove more difficult, since the OpenTelemetry SDK's API around metrics is more consumer facing than raw plumbing. I'll spend some more time looking at it though.

Not every application will want to build on the OpenTelemetry SDK, but I think it's worth any diagnostic framework putting effort into building and maintaining good integration with it.
